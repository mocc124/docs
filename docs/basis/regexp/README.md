# 正则表达式

## 一、模式和修饰符

正则表达式是提供了在文本中进行搜索和替换的强大的方式的模式。在 JavaScript 中，我们可以通过 [RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)对象使用它们，也可以与字符串方法结合使用。

### 1. 创建正则表达式对象

方式 1：使用 new 关键字创建

```js
regexp = new RegExp("pattern", "flags");
```

方式 2：使用斜线 "/",字面量的方式

```js
regexp = /pattern/; // 没有修饰符
regexp = /pattern/gim; // 带有修饰符 g、m 和 i（后面会讲到）
```

斜线 `/.../`告诉 JavaScript 这是一个正则表达式。它的作用与字符串引号的作用相同。

上面这两种情况，regexp 都会成为内建类 RegExp 的一个实例。

这两种语法之间的主要区别在于，使用斜线的模式不允许插入表达式（如带有 ${...} 的字符串模板）。它是完全静态的。

### 2. 修饰符

在 JavaScript 中，有 6 个修饰符：

| 修饰符 | 作用                                                       |
| ------ | ---------------------------------------------------------- |
| i      | 搜索时不区分大小写：A 和 a 之间没有区别                    |
| g      | 搜索时会寻找所有的匹配项 —— 没有它，则仅返回第一个匹配项。 |
| m      | 多行模式                                                   |
| s      | 启用 “dotall” 模式，允许点 . 匹配换行符 \n                 |
| u      | 开启完整的 Unicode 支持。该修饰符能够正确处理代理对        |
| y      | 粘滞模式                                                   |

### 3. 搜索：str.match

str.match(regexp) 方法会在字符串 str 中寻找 regexp 的所有匹配项。

它有 3 种工作模式：

如果正则表达式具有修饰符 g，它返回一个由所有匹配项所构成的数组：
如果没有这样的修饰符，它则会以数组形式返回第一个匹配项，索引 0 处保存着完整的匹配项，返回的结果的属性中还有一些其他详细信息：
最后，如果没有匹配项，则返回 null（无论是否有修饰符 g）。

示例：

```js
let str =
  "Anything that can be written in JavaScript will eventually be written in JavaScript.";

let green = str.match(/JavaScript/gi);
console.log(green); // [ 'JavaScript', 'JavaScript' ]);

green = str.match(/JavaScript/i);
console.log(green[0]); // JavaScript
console.log(green.length); // 1
console.log(green.index); // 32
console.log(green.input); // Anything that can be written ...

green = str.match(/HTML/i);
console.log(green); // null
```

### 4. 替换：str.replace

str.replace(regexp, replacement) 方法使用 replacement 替换在字符串 str 中找到的 regexp 的匹配项（如果带有修饰符 g 则替换所有匹配项，否则只替换第一个）。

注意：第二个参数 replacement 中，我们可以在其中使用特殊的字符组合来对匹配项进行插入：

| 符号      | 在替换字符串中的行为                                |
| --------- | --------------------------------------------------- |
| $&        | 插入整个匹配项                                      |
| $`        | 插入字符串中匹配项之前的字符串部分                  |
| $'        | 插入字符串中匹配项之后的字符串部分                  |
| $n        | 如果 n 是一个 1-2 位的数字，则插入第 n 个分组的内容 |
| `$<name>` | 插入带有给定 name 的括号内的内容                    |
| `$$`      | 插入字符 $                                          |

示例：

```js
let str = "I am accustomed to using JavaScript.";

let replaceStr = str.replace(/JavaScript/g, "$& and HTML");

console.log(replaceStr); // I am accustomed to using JavaScript and HTML.
```

### 5. 测试：regexp.test

regexp.test(str) 方法寻找至少一个匹配项，如果找到了，则返回 true，否则返回 false。

### 6. 总结

正则表达式由模式和可选择修饰符构成：g、i、m、u、s 和 y。
没有修饰符和特殊符号（稍后我们会学到），那么正则表达式的搜索和子字符串的搜索相同。
str.match(regexp) 方法寻找匹配项：如果带有修饰符 g，则会返回所有匹配项，否则只会返回第一个匹配项。
str.replace(regexp, replacement) 方法使用 replacement 替换 regexp 的匹配项：如果带有修饰符 g，则会替换所有匹配项，否则只会替换第一个匹配项。
regexp.test(str) 方法用于测试，如果找到至少一个匹配项则返回 true，否则返回 false。

## 二、字符类

字符类（Character classes） 是一种特殊的符号，匹配特定集合中的任何符号。

### 1. 常用字符类

最常用的字符类：

| 字符类                 | 说明                                                        |
| ---------------------- | ----------------------------------------------------------- |
| \d（“d” 来自 “digit”） | 数字：从 0 到 9 的字符                                      |
| \s（“s” 来自 “space”） | 空格符号：包括空格，制表符 \t，换行符 \n 和其他少数稀有字符 |
| \w（“w” 来自 “word”）  | “单字”字符：拉丁字母或数字或下划线 \_                       |

例如，`\d\s\w` 表示“数字”，后跟“空格字符”，后跟“单字字符”，例如 `1 a`。
正则表达式也可能同时包含常规符号和字符类,如 /CSS\d/ 匹配` CSS1`、`CSS2`、`CSS3 `等等
字符类也可以连用，如/\w\w\w\s\d/ 匹配` CSS 1`、`tom 2`、`abc 3 `等等

### 2.反向类

对于每个字符类，都有一个“反向类”，用相同的字母表示，但是大写的。

“反向”表示它与所有其他字符匹配，如下：

| 字符类 | 说明                                                     |
| ------ | -------------------------------------------------------- |
| \D     | 非数字：除 \d 以外的任何字符，例如字母。                 |
| \S     | 非空格符号：除 \s 以外的任何字符，例如字母。             |
| \W     | 非单字字符：除 \w 以外的任何字符，例如非拉丁字母或空格。 |

从 +7(903)-123-45-67 字符串中找到所有的数字并将它们连接起来：

```js
let userPhone = "+7(903)-123-45-67";

console.log(userPhone.match(/\d/gi).join("")); // 79031234567
console.log(userPhone.replace(/\D/gi, "")); // 79031234567
```

### 3. 通配符 . 与修饰符 s

点 . 是一种特殊字符类，它与“除换行符之外的任何字符”匹配。
需要注意:注意，点表示“任何字符”，而不是“缺少字符”。必须有一个与之匹配的字符：

```js
let regexp = /CS.\d/;

console.log("CSS3".match(regexp));
console.log("CSs3".match(regexp));
```

默认情况下，点与换行符 \n 不匹配。但是在很多情况下，我们希望点能够匹配“任何字符”，包括换行符。
如果有一个正则表达式具有修饰符 s，那么点 . 就可以能够匹配任何字符：

```js
console.log("A\nB".match(/A.B/s)); // A\nB（匹配了！）
```

注意：IE 浏览器不支持 s 修饰符。

### 4. 总结

存在以下字符类：

\d —— 数字。
\D —— 非数字。
\s —— 空格符号，制表符，换行符。
\S —— 除了 \s 。
\w —— 拉丁字母，数字，下划线 '\_'。
\W —— 除了 \w。
. —— 带有修饰符 's' 时匹配任何字符，否则匹配除换行符 \n 之外的任何字符。
……但这还不是全部！

JavaScript 用于字符串的 Unicode 编码提供了很多字符属性，例如：这个字母属于哪种语言（如果它是一个字母），它是标点符号吗，等等。

我们也可以通过这些属性进行搜索。这需要修饰符 u。

## 三、Unicode: 修饰符 "u" 和类 \p{...}

### 1. 修饰符 "u"

JavaScript 对字符串使用 Unicode 编码。大多数字符使用 2 个字节编码，但这种方式只能编码最多 65536 个字符。因此后面出现了四个字节编码的字符。如 𝒳（数学符号 X）或 😄（笑脸），一些象形文字等等。
直到现在 JavaScript 依然存在一些 bug，如无法正确识别字符长度:

```js
console.log("a".length); // 1
console.log("α".length); // 1

// length 认为下面有 2 个字符：
console.log("𝒳".length); // 2
console.log("😄".length); // 2
```

上面关键在于 length 把 4 个字节当成了 2 个 2 字节长的字符。这是不对的，因为它们必须被当作一个整体来考虑（即“[代理对（surrogate pair）](https://zh.javascript.info/string#dai-li-dui)”）。在默认情况下，正则表达式也会把一个 4 个字节的“长字符”当成一对 2 个字节长的字符。正如在上面字符串中遇到的情况，这将会导致一些奇怪的结果。

与字符串有所不同的是，正则表达式有一个修饰符 u 被用以解决此类问题。当一个正则表达式带有这个修饰符后，4 个字节长的字符将被正确地处理，同时也能够使用 Unicode 属性进行查找了。

### 2. Unicode 属性 \p{…}

Unicode 中的每个字符都有很多属性。它们描述了字符所属的“类别”，包含了关于字符的各种信息。如一个字符具有 Letter 属性，这意味着这个字符归属于（任意语言的）字母表。而 Number 属性则表示这是一个数字：也许是阿拉伯数字，亦或是中文数字，等等。

我们可以查找具有某种属性的字符，写作 \p{…}。为了使用 \p{…}，一个正则表达式必须使用修饰符 u。如 `\p{Letter}` 表示任何语言中的一个字母。我们也可以使用 `\p{L}`，因为 L 是 Letter 的一个别名。对于每种属性而言，几乎都存在对应的缩写别名。
示例：

```js
let str = "A ბ ㄱ";

alert(str.match(/\p{L}/gu)); // A,ბ,ㄱ
alert(str.match(/\p{L}/g)); // null（没有匹配项，因为没有修饰符 "u"）
```

主要字符类别和子类别：

- 字母（Letter）L：
  - 小写（lowercase）Ll，
  - 修饰（modifier）Lm，
  - 首字母大写（titlecase）Lt，
  - 大写（uppercase）Lu，
  - 其它（other）Lo。
- 数字（Number）N：
  - 十进制数字（decimal digit）Nd，
  - 字母数字（letter number）Nl，
  - 其它（other）No。
- 标点符号（Punctuation）P：
  - 连接符（connector）Pc，
  - 横杠（dash）Pd，
  - 起始引号（initial quote）Pi，
  - 结束引号（final quote）Pf，
  - 开（open）Ps，
  - 闭（close）Pe，
  - 其它（other）Po。
- 标记（Mark）M（accents etc）：
  - 间隔合并（spacing combining）Mc，
  - 封闭（enclosing）Me，
  - 非间隔（non-spacing）Mn。
- 符号（Symbol）S：
  - 货币（currency）Sc，
  - 修饰（modifier）Sk，
  - 数学（math）Sm，
  - 其它（other）So。
- 分隔符（Separator）Z：
  - 行（line）Zl，
  - 段落（paragraph）Zp，
  - 空格（space）Zs。
- 其它（Other）C：
  - 控制符（control）Cc，
  - 格式（format）Cf，
  - 未分配（not assigned）Cn，
  - 私有（private use）Co，
  - 代理伪字符（surrogate）Cs。

当然除了上面列举常见的字符类和子列，也有其它派生的类别。而且 Unicode 支持很多不同的属性，不在列出，详情请查阅以下文档：

[列出一个字符的所有属性](https://unicode.org/cldr/utility/character.jsp)
[按照属性列出所有的字符](https://unicode.org/cldr/utility/list-unicodeset.jsp)
[属性的对应缩写形式](https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt)
[以文本格式整理的所有 Unicode 字符，包含了所有的属性](https://www.unicode.org/Public/UCD/latest/ucd/.)

现在我们要匹配首字母大写:

```js
let timeStr = "Time now";

console.log(timeStr.match(/\p{Lu}\p{L}\w+/gu));
```

### 3. 总结

修饰符 u 表示启用正则表达式中对 Unicode 的支持。

这意味着两件事：

- 4 个字节长的字符被以正确的方式处理：被看成单个字符，而不是 2 个 2 字节长的字符。
- Unicode 属性可以被用于查找：\p{…}。

有了 unicode 属性我们可以查找给定语言中的词，特殊字符（引用，货币）等等。

## 四、锚点：字符串开始^和末尾$

插入符号 ^ 和美元符号 $ 在正则表达式中具有特殊的含义。它们被称为“锚点”。

插入符号 ^ 匹配文本开头，而美元符号 $ 则匹配文本末尾。

在大部分场景下，我们实际上可以用 startsWith/endsWith 来代替。正则表达式应该被用于更加复杂的测试。

```js
let goodInput = "12:34";
let badInput = "12:345";

let regexp = /^\d\d:\d\d$/;
alert(regexp.test(goodInput)); // true
alert(regexp.test(badInput)); // false
```

注意：锚点“宽度”为零
锚点 ^ 和 $ 属于测试。它们的宽度为零。换句话说，它们并不匹配一个具体的字符，而是让正则引擎测试所表示的条件（文本开头/文本末尾）。

## 五、锚点 ^ $ 的多行模式，修饰符 "m"

多行模式由修饰符 m 启用。它只影响 ^ 和 $ 的行为。在多行模式下，它们不仅仅匹配文本的开始与末尾，还匹配每一行的开始与末尾。

```js
let str = `1st place: Winnie
2nd place: Piglet
3rd place: Eeyore`;

console.log(str.match(/^\d/gm)); // 1, 2, 3
```

没有修饰符 m 时，仅会匹配第一个数字：

```js
let str = `1st place: Winnie
2nd place: Piglet
3rd place: Eeyore`;

console.log(str.match(/^\d/g)); // 1
```

在默认情况下，锚点 ^ 仅匹配文本的开头，在多行模式下，它匹配行的开头。“行的开头”表示“就在换行符之后”：多行模式下的测试 ^ 匹配所有以换行符 \n 开头的位置。以及在文本开始的位置。
美元符 $ 的行为也类似。

```js
let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;

console.log(str.match(/\d$/gm)); // 1,2,3
```

没有修饰符 m，那么美元符 $ 将只会匹配整个文本的末尾，所以只有最后一个数字会被匹配。

请注意：“行的末尾”表示“就在换行符之前”：多行模式下的测试 $ 匹配所有以换行符 \n 结尾的位置。以及在文本末尾的位置。

要寻找新的一行，我们不仅可以使用锚点 ^ 和 $，也可以使用换行符 \n,如下

```js
let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;

console.log(str.match(/\d\n/g)); // 1\n,2\n
```

这里找到了 2 个匹配项而不是 3 个。

这是因为在 3 之后没有换行符（但是有文本末尾，所以它匹配 $）。

另一个区别是，现在每个匹配项都包含一个换行符 \n。与锚点 ^ $ 不同，锚点只测试条件（行的开始/末尾），而 \n 是一个字符，因此它成为了结果的一部分。

因此，当我们需要结果中有换行符时，使用 \n。而锚点则用于在行的开头/末尾查找某些内容。

## 六、词边界

词边界 \b 是一种检查，就像 ^ 和 $ 一样。

当正则表达式引擎（实现正则表达式搜索的程序模块）遇到 \b 时，它会检查字符串中的位置是否是词边界。

有三种不同的位置可作为词边界：

- 在字符串开头，如果第一个字符是单词字符 \w。
- 在字符串中的两个字符之间，其中一个是单词字符 \w，另一个不是。
- 在字符串末尾，如果最后一个字符是单词字符 \w。

示例:

```js
alert("Hello, Java!".match(/\bHello\b/)); // Hello
alert("Hello, Java!".match(/\bJava\b/)); // Java
// l 之后没有单词边界
alert("Hello, Java!".match(/\bHell\b/)); // null（无匹配项）
// 感叹号不是单词字符 \w，所以其后没有词边界
alert("Hello, Java!".match(/\bJava!\b/)); // null（无匹配项）
```

\b 既可以用于单词，也可以用于数字。

例如，模式 \b\d\d\b 查找独立的两位数。换句话说，它查找的是两位数，其周围是与 \w 不同的字符，例如空格或标点符号（或文本开头/结尾）。

```js
alert("1 23 456 78".match(/\b\d\d\b/g)); // 23,78
alert("12,34,56".match(/\b\d\d\b/g)); // 12,34,56
```

注意：词边界 \b 不适用于非拉丁字母

词边界测试 \b 检查该位置的一侧是否匹配 \w，而另一侧则不匹配 “\w”。但是，\w 表示拉丁字母 a-z（或数字或下划线），所以此检查不适用于其他字符，如西里尔字母（cyrillic letters）或象形文字（hieroglyphs）。

## 七、转义,特殊字符

正如我们所看到的，反斜杠 \ 用于表示字符类，例如 \d。所以它是正则表达式中的一个特殊字符（就像在常规字符串中一样）。

还存在其它特殊字符，这些字符在正则表达式中有特殊的含义，例如 [ ] { } ( ) \ ^ $ . | ? \* +。它们用于执行更强大的搜索。

```js
alert("Chapter 5.1".match(/\d\.\d/)); // 5.1（匹配了！）

alert("function g()".match(/g\(\)/)); // "g()"

alert("1\2".match(/\\/)); // '\'

alert("/".match(/\//)); // '/'
```

从另一个方面看，如果我们没使用 /.../，而是使用另一种 new RegExp 的方式创建正则表达式，则不需要转义斜杠：

```js
alert("/".match(new RegExp("/"))); // '/'
```

但是使用 new RegExp 的方式创建正则表达式会带来一个问题,如下：

```js
// let reg = new RegExp("\d\.\d");
let reg = new RegExp("d.d");

alert("Chapter 5.1".match(reg)); // null
```

因为反斜杠被字符串“消耗”了。在字符串中的反斜杠表示转义或者类似 \n 这种只能在字符串中使用的特殊字符。这个引用会“消耗”并且解释这些字符。也就是说调用 new RegExp 会获得一个没有反斜杠的字符串。
要修复这个问题，我们需要双斜杠，因为引用会把 \\ 变为 \：

```js
let regStr = "\\d\\.\\d";
alert(regStr); // \d\.\d（现在对了）

let regexp = new RegExp(regStr);

alert("Chapter 5.1".match(regexp)); // 5.1
```

总结：
要在字面意义上搜索特殊字符 [ \ ^ $ . | ? \* + ( )，我们需要在它们前面加上一个反斜杠 \（“转义它们”）。
如果在 /.../ 内（但不在 new RegExp 内），我们还需要转义 /。
当将字符串传递给给 new RegExp 时，我们需要双反斜杠 \\，因为字符串引号会消耗一个反斜杠。

## 八、集合和范围

在方括号 `[…]` 中的几个字符或者字符类表示“搜索给定字符中的任意一个”。
集合：
在正则表达式中，可以将集合和常规字符一起使用。
注意，虽然集合中有多个字符，但它们在匹配中只会对应其中的一个。
示例:

```js
// 查找 [t 或 m]，然后匹配 "op"
alert("Mop top".match(/[tm]op/gi)); // "Mop", "top"
```

方括号也可以包含 字符范围。

例如，`[a-z]`表示从 a 到 z 范围内的字符，`[0-5]`表示从 0 到 5 的数字。

```js
alert("Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g)); // xAF
```

如果我们还想查找小写字母，则可以添加范围 a-f：[0-9A-Fa-f]。或添加标志 i。

我们也可以在 `[…]`中使用字符类。例如，如果我们想查找单词字符 \w 或连字符 -，则集合可以写为 `[\w-]`。也可以组合多个类，例如 `[\s\d]` 表示“空格字符或数字”。

除了普通的范围匹配，还有像这样 `[^…]` 的“排除”范围匹配。

示例：

- `[^aeyo]` —— 匹配除了 'a'、'e'、'y' 或 'o' 之外的任何字符。
- `[^0-9]` —— 匹配除了数字之外的任何字符，与 \D 作用相同。
- `[^\s]` —— 匹配任何非空格字符，与 \S 作用相同。

在方括号，我们可以使用绝大多数特殊字符而无需转义：

- 符号 . + ( ) 无需转义。
- 在开头或结尾（未定义范围）的连字符 - 不会被转义。
- 插入符号 ^ 仅在开头会被转义（表示排除）。
- 右方括号 ] 总是会被转义（如果我们需要寻找那个符号）。

```js
// 不需要转义
let reg = /[-().^+]/g;

alert("1 + 2 - 3".match(reg)); // 匹配 +，-
```

如果集合中有代理对（surrogate pairs），则需要标志 u 才能使它们正常工作。
例如，让我们在字符串 𝒳 中查找 [𝒳𝒴]：

```js
alert("𝒳".match(/[𝒳𝒴]/)); // 显示了一个奇怪的字符
```

这是因为默认情况下正则表达式“不知道”代理对。正则表达式引擎认为 `[𝒳𝒴]` —— 不是两个字符，而是四个字符：

## 九、量词 +, \*, ? 和 {n}

数字是一个或多个数字 \d 的序列。为了标记我们需要的数量，我们需要加一个 量词。

在一个字符（或一个字符类，或 `[...]` 等）后附加一个量词，用来指出我们具体需要的数量。最简单的量词便是大括号中的数字：{n}。

如：\d{5} 表示 5 位数，与 \d\d\d\d\d 相同。
示例:

```js
alert("I'm 12345 years old".match(/\d{5}/)); //  "12345"
```

我们可以添加 \b 来排除位数更多的数字：\b\d{5}\b。也可以指定范围，如要查找 3-5 位的数字，我们可以将限制写在花括号中：\d{3,5}

```js
alert("I'm not 12, but 1234 years old".match(/\d{3,5}/)); // "1234"
```

如果省略了上限,那么正则表达式 \d{3,} 就会查找位数大于等于 3 的数字：

```js
alert("I'm not 12, but 345678 years old".match(/\d{3,}/)); // "345678"
```

大多数常用的量词都有简写形式:

- \+ 与{1,}相同。表示一个或多个，即至少有一个
- ? 与 {0,1} 相同代表“零个或一个”，。换句话说，它使得符号变得可选。
- \* 与 {0,} 相同。代表“零个及以上”，也就是说，字符可以出现任何次数或者不出现。

注意：量词是很常用的。它们是构成复杂正则表达式的主要“模块”，下面是一些示例：
小数的正则表达式:`\d+\.\d+`
HTML 标签的正则表达式:`/<[a-z]+>/i`或者`/<\/?[a-z][a-z0-9]*>/i`

## 十 量词的匹配模式

### 贪婪模式（默认）

默认情况下，正则表达式引擎会尝试尽可能多地重复量词字符。例如，\d+ 会消耗所有可能的字符。当无法消耗更多（在尾端没有更多的数字或字符串）时，然后它再匹配模式的剩余部分。如果没有匹配，则减少重复的次数（回溯），并再次尝试。

### 惰性模式

通过在量词后添加问号 ? 来启用。正则表达式引擎尝试在每次重复量化字符之前匹配模式的其余部分。
正如我们所见，惰性模式并不是贪婪搜索的“灵丹妙药”。另一种方式是使用排除项“微调”贪婪搜索，如模式 "[^"]+"。

## 未完 待后续补充
