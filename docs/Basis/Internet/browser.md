## http 通信以及浏览器解析

互联网通信可以简单理解为：浏览器发送请求，服务器解析并发送响应的过程。

快速响应的网站可以提供更好的用户体验。用户期待内容快速加载和流畅交互。而等待资源加载时间（在链路上传送二进制到电脑端所消耗的链路传输时间）和大部分情况下的浏览器单线程执行是影响 Web 性能的两大主要原因。

为了实现快速加载，开发者的目标就是尽可能快的发送请求，并等待服务器返回响应结果。之后大部分情况下，浏览器是单线程执行的。为了有流畅的交互，开发者需要确保网站从流畅的页面滚动到点击响应的交互性能。其中的关键要素是渲染时间，开发者要确保主线程可以完成所有给它的任务并且仍然一直可以处理用户的交互。通过了解浏览器单线程的本质与最小化主线程的责任可以优化 Web 性能，来确保渲染的流畅和交互响应的及时。

### 当在浏览器输入一个网址时，发生了什么？

1. 浏览器在域名系统（DNS）服务器上找出存放网页的服务器的 ip 地址。
2. 浏览器发送 HTTP 请求信息到服务器来请拷贝一份网页到客户端。这条消息，以及其他所有在客户端和服务器之间传递的数据都是通过互联网使用 TCP/IP 协议传输的。
3. 服务器同意客户端的请求后，会返回一个 200 信息，然后开始将网页的文件以数据包的形式传输到浏览器。
4. 浏览器将数据包重新汇总整理成一个 html 文件，HTML 文件通常包含 `<link>` 和 `<script>` 元素，这些元素分别指向了外部的 CSS 样式表文件和 JavaScript 脚本文件。

### DNS 查询

第一次在浏览器输入域名之后，浏览器会向名称服务器发起 DNS 查询请求，最终得到一个 IP 地址。第一次请求之后，这个 IP 地址可能会被缓存，这样后续请求可以通过从缓存里面检索 IP 地址而不是再通过名称服务器进行查询从而加速请求。

如果一个页面中的字体（fonts）、图像（images）、脚本（scripts）、广告（ads）和网站统计（metrics）都指向了不同的主机名，则需要对每一个主机名进行 DNS 查询。

### TCP 握手

一旦获取到服务器 IP 地址，浏览器就会通过 TCP“三次握手”与服务器建立连接。

TCP 的“三次握手”：经常被称为“SYN-SYN-ACK”——更确切可以说是 SYN、SYN-ACK、ACK，因为通过 TCP 首先发送了三个消息进行协商，然后在两台电脑之间开始一个 TCP 会话。注意：这时请求还尚未发出。

三次握手机制的目的是让两端在通过上层协议 HTTPS 发送数据之前，尝试进行通信并协商网络 TCP 套接字连接的一些参数。

### TLS协商

为了在 HTTPS 上建立安全连接，[TLS](https://developer.mozilla.org/zh-CN/docs/Glossary/TLS)协商是必须的。它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。

虽然建立安全连接对增加了加载页面的等待时间，对于建立一个安全的连接来说，以增加等待时间为代价是值得的，因为在浏览器和 web 服务器之间传输的数据不可以被第三方解密。
![DNS&TLS 图示](https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/ssl.jpg)
经过 8 次往返，浏览器才可以发出请求（采用 https 协议）。

### 响应

两端建立连接之后，浏览器可以发出各种[HTTP 请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods),对于网站来说一般是 HTML 文件，一旦服务器收到请求，它将使用相关的响应头和 HTML 的内容进行回复。

这里有一个概念---[第一字节时间（TTFB）](https://developer.mozilla.org/zh-CN/docs/Glossary/time_to_first_byte)，指用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间（DNS 查找和三次 TCP 握手和 SSL/TLS 握手建立连接）。

初始请求的响应包含所接收数据的第一个字节。第一个内容分块通常是 14KB 的数据。

### 浏览器解析

“解析”是浏览器将通过网络接收的数据转换为 DOM 和 CSSOM 的步骤，通过渲染器把 DOM 和 CSSOM 在屏幕上绘制成页面。

补充：DOM 是浏览器标记的内部表示。同时 DOM 也是被暴露的，可以通过 JavaScript 中的 API 进行 DOM 操作。

浏览器解析html文件，大致可以总结为一下四步：
1. 浏览器首先解析 HTML 文件，并从中识别出所有的 `<link>` 和 `<script>` 元素，获取它们指向的外部文件的链接。
2. 继续解析 HTML 文件的同时，浏览器根据外部文件的链接向服务器发送请求，获取并解析 CSS 文件和 JavaScript 脚本文件。
3. 接着浏览器会给解析后的 HTML 文件生成一个 [DOM](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model)树（在内存中），会给解析后的 CSS 文件生成一个 [CSSOM](https://developer.mozilla.org/zh-CN/docs/Glossary/CSSOM) 树（在内存中），并且会编译和执行解析后的 JavaScript 脚本文件。
4. 伴随着构建 DOM 树、应用 CSSOM 树的样式、以及执行 JavaScript 脚本文件，浏览器会在屏幕上绘制出网页的界面；意味着用户可以跟网页交互了。

补充：
一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。即使请求页面的 HTML 大于初始的 14KB（为什么是14kb，详见TCP慢启动）数据包，
浏览器也将开始解析并尝试根据其拥有的数据进行渲染。这就是为什么在前 14KB 中包含浏览器开始渲染页面所需的所有内容，
或者至少包含页面模板（第一次渲染所需的 CSS 和 HTML）对于 web 性能优化来说是很重要的。

### 解析
⭐ 构建 DOM 树

第一步是处理 HTML 标记并构造 DOM 树。HTML 解析涉及到 [tokenization](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMTokenList)和树的构造。HTML 标记包括开始和结束标记，以及属性名和值。如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建文档树。

DOM 树描述了文档的内容。`<html>` 根元素是第一个标签也是文档树的根节点。树反映了不同标记之间的关系和层次结构。嵌套在其他标记中的标记是子节点。DOM 节点的数量越多，构建 DOM 树所需的时间就越长。
![DOM tree](https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/dom.gif)
当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个 CSS 文件时，解析也可以继续进行，但是对于 `<script> `标签（特别是没有 **async** 或者 **defer** 属性的）会阻塞渲染并停止 HTML 的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。

因此为了确保脚本不会阻塞进程，当 JavaScript 解析和执行顺序不重要时，可以添加 async 属性或 defer 属性。

⭐ 构建 CSSOM 树

第二步是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似但独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。

CSSOM 树包括来自用户代理样式表的样式。浏览器从适用于节点的最通用规则开始，并通过应用更具体的规则递归地优化计算的样式。换句话说，它级联属性值。

构建 CSSOM 非常快，可以在开发人员工具中的“重新计算样式”显示解析 CSS、构建 CSSOM 树和递归计算计算样式所需的总时间。在 web 性能优化方面，它也是可轻易实现的，因为创建 CSSOM 的总时间通常小于一次 DNS 查询所需的时间。

⭐ JavaScript 编译

当 CSS 被解析并创建 CSSOM 时，其他资源，包括 JavaScript 文件正在下载（借助预加载扫描器）。

JavaScript 被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用抽象语法树并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的 JavaScript 编译。

⭐ 构建 AOM 树

浏览器还构建辅助设备用于分析和解释内容的辅助功能（[accessibility](https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility)）树。无障碍对象模型（AOM）类似于 DOM 的语义版本。当 DOM 更新时，浏览器会更新辅助功能树。辅助技术本身无法修改无障碍树。

在构建 AOM 之前，屏幕阅读器（screen readers (en-US)）无法访问内容。

### 渲染
渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。在解析步骤中创建的 CSSOM 树和 DOM 树会被组合成一个 Render 树，用于计算每个可见元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是 CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。

⭐ Style

第三步是将 DOM 和 CSSOM 组合成一个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点。

每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 [CSS 级联](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)确定每个节点的计算样式。

像 `<head>`和它的子节点以及`<body>`中任何具有`display: none`样式的结点，例如 `script { display: none; }`（在 user agent stylesheets 可以看到这个样式）这些标签将不会显示，也就是它们不会出现在 Render 树上。

以及具有`visibility: hidden`的节点会出现在 Render 树上，因为它们会占用空间。

⭐ Layout

第四步是在渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。

构建渲染树后，开始布局。渲染树标识显示哪些节点（即使不可见）及其计算样式，但不标识每个节点的尺寸或位置。为了确定每个对象的确切大小和位置，浏览器从渲染树的根开始遍历它。

以视区的大小为基础，布局通常从 body 开始，用每个元素的框模型属性排列所有 body 的子孙元素的尺寸，为不知道其尺寸的替换元素（例如图像）提供占位符空间。

第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。在我们的示例中，假设初始布局发生在返回图像之前。由于我们没有声明图像的大小，因此一旦知道图像大小，就会有回流。
回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。

⭐ 绘制

最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为 “first meaningful paint”。

在绘制或光栅化阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。绘画包括将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素（如按钮和图像）。浏览器需要非常快地完成这项工作。

为了确保平滑滚动和动画，占据主线程的所有内容，包括计算样式，以及回流和绘制，必须让浏览器在 16.67 毫秒内完成。而且为了确保重绘的速度比初始绘制的速度更快，屏幕上的绘图通常被分解成数层。如果发生这种情况，则需要进行合成。

绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。有一些特定的属性和元素可以实例化一个层，包括 `<video>` 和 `<canvas>`，任何 CSS 属性为 opacity 、3D transform、will-change 的元素，还有一些其他元素。这些节点将与子节点一起绘制到它们自己的层上，除非子节点由于上述一个（或多个）原因需要自己的层。

分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。

⭐ Compositing

当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

当页面继续加载资源时，可能会发生回流，回流会触发重新绘制和重新组合。如图像迟到，图像如果在此之前已经定义了图像的大小，就不需要重新绘制，只需要重新绘制需要重新绘制的层，并在必要时进行合成。但没有定义图像大小！则从服务器获取到图像后，渲染过程将返回到布局步骤并从那里重新开始！

### 交互

主线程绘制页面完成后，如果加载包含 JavaScript（并且延迟到 load 事件激发后执行），则主线程会去解析、编译和执行 JavaScript，则它不可用，因此无法及时（小于 50ms）响应用户交互（请了解 TTI、FCPD 等）

## http请求优化策略

### TCP 慢启动 / 14KB 规则

慢启动是一种均衡网络连接速度的算法。慢启动逐渐增加发送数据的数量直到达到网络的最大带宽。所以第一个响应数据包是 14KB 大小的，这是慢启动的一部分。

慢启动策略：在 TCP 慢启动 中，收到初始包后，服务器会将下一个数据包的大小加倍到大约 28KB。后续的数据包依次是前一个包大小的二倍直到达到预定的阈值，或者遇到拥塞。

## 拥塞控制

由于硬件和网络条件，连接的带宽容量是有限的。如果服务器太快地发送太多的数据包，一些数据包可能会被丢弃。因此当服务器用 TCP 数据包来发送数据时，客户端需要通过返回确认帧来确认传输的有效性。被丢弃的数据包不会有确认帧的返回。

最终拥塞控制算法使用这个发送包和确认帧流来确定发送速率。